# YX5200 (DFPlayer-compatible) UART Library

A small C library to control audio modules based on the YX5200 chipset (e.g., DFPlayer Mini and compatibles) via UART.  
It formats and transmits protocol frames (0x7E ... 0xEF), provides a simple control API, and optionally supports
receiving and parsing device responses when feedback is enabled.

- MCU stack: STM32 HAL UART
- Language: C11

Note: If feedback is disabled, transmissions are blocking and include a 100 ms post-send delay for robustness.

## Features

- Basic playback control: play, pause, next, previous, reset, stop.
- Play by global track index (1..2999).
- Play a file in a folder (folders 01..99, files 1..255).
- Volume 0..30, equalizer presets (Normal/Pop/Rock/Jazz/Classic).
- Play modes: all loop, folder loop, single loop (current track), random.
- Source selection: USB/SD.
- Advertisement playback control (insert/stop).
- Optional feedback and RX parser:
  - When enabled, the device may send responses to commands and queries.
  - Lightweight state machine to parse 10-byte frames with checksum verification.
  - Weak callbacks to receive parsed frames and errors.

## Library Integration and Setup (STM32CubeMX + CMake)

This section explains how to integrate the library into a STM32 project generated by STM32CubeMX using the CMake toolchain and how to pin the library version via a Git sub-repository.

1) Create a CMake-based STM32 project in CubeMX
- In STM32CubeMX, set Project Manager → Toolchain/IDE to “CMake”
- Generate the project. You will get a CMake-based layout suitable for CLion or other CMake IDEs.

2) Add a folder for external libraries
- In your project root, create a folder to host third-party code, for example:
```shell
  mkdir -p Libs
```

3) Add this library as a Git sub-repository (recommended to pin a version)
- Option A: Git submodule
  ```shell
  git submodule add <REPO_URL> Libs/yx5200
  ```

  ```shell
  # Optionally, check out a specific tag/commit to pin the version:
  cd Libs/yx5200
  git checkout <tag-or-commit>
  cd ../..
  git commit -m "Add yx5200 as a submodule"
  ```

- Option B: Git subtree (alternative to submodules)
  ```shell
  git subtree add --prefix=Libs/yx5200 <REPO_URL> <branch> --squash
  ```
  ```shell
  # To update later:
  git subtree pull --prefix=Libs/yx5200 <REPO_URL> <branch> --squash
  ```

- Option C: Plain clone (quick test; pin by commit)
  ```shell
  git clone <REPO_URL> Libs/yx5200
  cd Libs/yx5200 && git checkout <tag-or-commit> && cd ../..
  ```

4) Wire the library into your CMake build
- In your top-level CMakeLists.txt (or an appropriate module CMake file), add:
```cmake
# Add the library directory
add_subdirectory(Libs/yx5200)
# Link it to your application target
target_link_libraries(${CMAKE_PROJECT_NAME}
        stm32cubemx

        # Add user defined libraries
        yx5200
)
# Link application to the library target
target_link_libraries(yx5200 PRIVATE stm32cubemx)
```

5) Regenerate and reload CMake
- After changes, reload/reconfigure your CMake project in the IDE (or run CMake configure/generate from CLI).

6) Configure UART and test
- Make sure the UART used for the module is properly configured in CubeMX (e.g., 9600 8N1).
- Initialize the library in your application code and run a basic command to verify TX/RX works.

Notes
- Using a submodule or subtree allows you to keep the library version pinned and update it explicitly.
- If you regenerate CubeMX code, your Libs/ folder and CMake additions should remain intact as long as you keep them outside auto-generated sections.

---

## Getting Started

### 1) Initialize the library

Pass your HAL UART handle and whether you want feedback ACKs.

```c 
// #include "yx5200.h"
extern UART_HandleTypeDef huartX; // your configured UART
int main(void) { 
    // ... HAL_Init(), clocks, GPIO, UART init ... 
    yx5200_setup(&huartX, 0); // feedback: 0 = no ACKs, 1 = request ACKs
    while (1) {
        // ...
    }
}
```

### 2) Send commands

```c 
// Select source: SD card 
yx5200_set_source(YX5200_SRC_SD); 
// Volume 20 
yx5200_set_volume(20); 
// Equalizer: Rock 
yx5200_set_equalizer(YX5200_EQ_ROCK); 
// Play by global index 
yx5200_play_track(123); 
// Play file 004 in folder 02 
yx5200_play_folder_file(2, 4); 
// Loop modes 
yx5200_set_all_loop(1); // enable "all loop" 
yx5200_set_all_loop(0); // disable 
yx5200_set_single_loop(1); 
// 0x19: loop current track on 
yx5200_set_single_loop(0); // off 
yx5200_play_folder_loop(2); // loop folder 02 
// Random playback 
yx5200_play_random(); 
// Advertisement insert 
yx5200_advert_play(5); // play AD track #5 
yx5200_advert_stop(); // stop AD playback
// Stop playback 
yx5200_stop(); 

// Examples (receive via your callbacks / polling) 
yx5200_query_status(); // 0x42 
yx5200_query_volume(); // 0x43 
yx5200_query_total_usb(); // 0x47 
yx5200_query_total_sd(); // 0x48 
yx5200_query_current_usb(); // 0x4B 
yx5200_query_current_sd(); // 0x4C

```

## Enabling Feedback and Receiving Replies (Optional)

Set feedback to 1 at initialization to request device replies.

```c
yx5200_setup(&huartX, 1); // request replies
```

You have two options to feed received bytes into the parser.

### Option A: Interrupt-driven RX (1-byte IT)

- Start IT reception once after init:

```c
yx5200_rx_start_it();
```

- In your HAL UART RX complete callback, forward the event to the library:

```c
void HAL_UART_RxCpltCallback(UART_HandleTypeDef* huart) { 
    yx5200_rx_on_cplt(huart); // library consumes the byte and restarts 1-byte IT
}
```

### Option B: DMA + IDLE chunks

If you already receive into a ring or linear DMA buffer and detect IDLE:

- Pass the new data block to the parser:

```c
// data,len = the new bytes captured since the last IDLE 
yx5200_rx_process_bytes(data, len);
```

## Parameter Ranges

- Volume: 0..30
- Global track index: 1..2999
- Folder: 1..99
- File in folder: 1..255
- MP3 folder track: 1..3000

The library does not clamp these values; ensure correctness on the caller side.

## Protocol Details (Reference)

Frame (10 bytes):
- 0: 0x7E (start)
- 1: 0xFF (version; fixed 0xFF)
- 2: 0x06 (length)
- 3: command
- 4: feedback (0 or 1)
- 5: param high (DH)
- 6: param low  (DL)
- 7: checksum high
- 8: checksum low
- 9: 0xEF (end)

Checksum is the two’s complement of the sum of bytes 1..6:

```c
checksum = (uint16_t)(0 - (ver + len + cmd + feedback + DH + DL))
```

## Timing and Blocking Behavior

- Transmits are blocking (HAL_UART_Transmit with HAL_MAX_DELAY).
- A small delay (~100 ms) is inserted after each command to avoid overruns on slower modules if no feedback is requested.
    - You may tune or remove it if your setup is stable and responsive.

## Integration Tips

- Ensure UART TX and RX are configured at the module’s expected baud rate (commonly 9600 8N1).
- If you only need one-way control, initialize with feedback = 0 and omit RX integration.
- If you implement Interrupt-driven RX reception:
    - Make sure to call `yx5200_rx_on_cplt(huartX)` in your HAL UART RX complete callback. 
- If you implement DMA+IDLE reception:
    - Make sure to provide contiguous data slices to `yx5200_rx_process_bytes(...)`.
    - Handle buffer wrap-around in your DMA ring before feeding the parser.

## Troubleshooting

- No replies from the device:
    - Make sure feedback was enabled at init (feedback = 1).
    - Verify module firmware supports replies and the UART wiring is correct (TX/RX crossed).
- Parser errors (bad start/end/length/checksum):
    - Check baud rate and signal integrity.
    - Ensure you pass unmodified data slices and do not drop bytes.
- Commands sometimes ignored:
    - Reduce command rate or adjust the post-send delay.
    - Verify that SD/USB media is present and files/folders follow expected naming.

---

